{-# LANGUAGE FlexibleInstances #-}

-- (c) Alex McLean and contributors 2022
-- Shared under the terms of the GNU Public License v3.0

-- Please do not edit this file directly, it's generated from
-- bin/generate-composers.hs

module Sound.Tidal.Compose where

import Prelude hiding ((<*), (*>))
import Control.Monad (forM)
import Data.Bits

import qualified Data.Map.Strict as Map

import Sound.Tidal.Signal

-- ************************************************************ --
-- Hack to allow 'union' to be used on any value

-- class for types that support a left-biased union
class Unionable a where
  union :: a -> a -> a

-- default union is just to take the left hand side..
instance Unionable a where
  union = const

instance {-# OVERLAPPING #-} Unionable ValueMap where
  union = Map.union

-- ************************************************************ --

opMix :: Applicative t => (a -> b -> c) -> t a -> t b -> t c
opMix f a b = f <$> a <*> b

opIn :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opIn f a b = f <$> a <* b
  
opOut :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opOut f a b = f <$> a *> b

opSqueeze :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueeze f a b = squeezeJoin $ fmap (\a -> fmap (\b -> f a b)  b) a
  
opSqueezeOut :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opSqueezeOut f pata patb = squeezeJoin $ fmap (\a -> fmap (\b -> f b a)  pata) patb

opTrig :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrig f a b = trigJoin $ fmap (\a -> fmap (\b -> f a b)  b) a
  
opTrigZero :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
opTrigZero f a b = trigZeroJoin $ fmap (\a -> fmap (\b -> f a b)  b) a

-- ************************************************************ --

-- Aliases

(#) :: Unionable b => Signal b -> Signal b -> Signal b
(#) = (|=)

-- ************************************************************ --

